/**
 * @brief The nodes of the DAG
 * 
 */
struct dagNode
{
    /// @brief the bitset of the node
    standardBitset mask;
    /// @brief the canonical form of the node
    int ix;
    /// the size + 1 bitsets generated by the bitset of the node
    vi children;

    dagNode(){}

    dagNode(const standardBitset &_mask, int _ix, vector<standardBitset> &_children,
        std::unordered_map<standardBitset, int> &bitsetToIndex):
    mask(_mask), ix(_ix)
    {
        children.resize(_children.size());
        for (size_t i = 0; i < children.size(); i++)
        {
            children[i] = bitsetToIndex[_children[i]];
        }
    }
};

/**
 * @brief Comparator struct used to sort the nodes of the DAG
 * 
 */
struct CompareDagNode {
    bool operator()(const dagNode &a, const dagNode &b) const {
        // Compare from most significant bit down to 0.
        for (int i = univEdgeList.size(); i >= 0; i--) {
            if (a.mask[i] ^ b.mask[i]) 
            return b.mask[i];
        }
        return 0;
    }
};

/// DAG used to enumerate duplicatable subgraphs
vector<vector<dagNode> > DAG;

/**
 * @brief Converts the tempDAG generated by initialRecursiveEnumeration into the more efficient DAG 
 * used on all subsequent passes of the algorithm
 * 
 */
void convertDag(vector<std::unordered_map<standardBitset, pair<int, vector<standardBitset> > > > & tempDag)
{
    DAG.resize(tempDag.size());
    vector<std::unordered_map<standardBitset, int> > bitsetToIndex(tempDag.size());
    for (size_t i = 0; i < tempDag.size() - 1; i++)
    {
        for (auto it = tempDag[i].begin(); it != tempDag[i].end(); ++it)
        {
            vector<standardBitset> &list = it->second.second;
            size_t trueSize = list.size();
            for (size_t j = 0; j < list.size(); j++)
            {
                std::unordered_map<standardBitset, pair<int, vector<standardBitset> > > &nextMap = tempDag[i + 1];
                if (nextMap.count(list[j]) == 0)
                {
                    list[j] = 0;
                    trueSize--;
                }
            }
            vector<standardBitset> trueList(trueSize);
            size_t k = 0;
            for (size_t j = 0; j < list.size(); j++)
            {
                if (list[j] != 0)
                {
                    trueList[k] = list[j];
                    k++;
                }
            }    
            it->second.second = trueList;
            if (i > 0)
            {
                it->second.first = bitsetHashTable[it->first].first;
                size_t x = bitsetToIndex[i].size();
                bitsetToIndex[i][it->first] = x;
            }
        }
    }
    for (auto it = tempDag[tempDag.size() - 1].begin(); it != tempDag[tempDag.size() - 1].end(); ++it)
    {
        it->second.first = bitsetHashTable[it->first].first;
    }
    for (size_t i = 0; i < DAG.size() - 1; i++)
    {
        for (auto it = tempDag[i].begin(); it != tempDag[i].end(); ++it)
        {
            dagNode dn(it->first, it->second.first, it->second.second, bitsetToIndex[i + 1]);
            DAG[i].push_back(dn);
        }
    }
    sort(DAG[0].begin(), DAG[0].end(), CompareDagNode());
}
