/**
 * @file dagEnumeration.h
 * @brief Code relating to the DAG
 */
#pragma once
#include <stddef.h>           // for size_t
#include <bitset>             // for bitset, hash
#include <unordered_map>      // for unordered_map
#include <utility>            // for pair
#include <vector>             // for vector
#include "globalPrimitives.h" // for standardBitset, univEdgeList, vi

/**
 * @brief The nodes of the DAG
 *
 */
struct dagNode
{
    /// @brief the bitset of the node
    standardBitset mask;
    /// @brief the canonical form of the node
    int ix;
    /// the size + 1 bitsets generated by the bitset of the node
    vi children;

    dagNode() {}

    dagNode(const standardBitset &_mask, int _ix, std::vector<standardBitset> &_children,
            std::unordered_map<standardBitset, int> &bitsetToIndex) : mask(_mask), ix(_ix)
    {
        children.resize(_children.size());
        for (size_t i = 0; i < children.size(); i++)
        {
            children[i] = bitsetToIndex[_children[i]];
        }
    }
};

/**
 * @brief Comparator struct used to sort the nodes of the DAG
 *
 */
struct CompareDagNode
{
    bool operator()(const dagNode &a, const dagNode &b) const
    {
        // Compare from most significant bit down to 0.
        for (int i = univEdgeList.size(); i >= 0; i--)
        {
            if (a.mask[i] ^ b.mask[i])
                return b.mask[i];
        }
        return 0;
    }
};

/// DAG used to enumerate duplicatable subgraphs
extern std::vector<std::vector<dagNode>> DAG;

/**
 * @brief Converts the tempDAG generated by initialRecursiveEnumeration into the more efficient DAG
 * used on all subsequent passes of the algorithm
 *
 */
void convertDag(std::vector<std::unordered_map<standardBitset, std::pair<int, std::vector<standardBitset>>>> &tempDag);
